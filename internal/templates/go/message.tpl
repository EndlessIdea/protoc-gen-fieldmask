// {{ .InMessage.Name }} is used for the template literal syntax.
// message generated by yeqown.

{{ $inMessageName := .InMessage.Name }}
{{ $outMessageName := .OutMessage.Name }}
{{ $fmField := .FieldMaskField }}

{{ range $idx, $f := .OutMessage.Fields }}
    // Mask_{{ $f.Name.UpperCamelCase }} indicates append {{ $outMessageName }}.{{ $f.Name.UpperCamelCase }} into
    // {{ $inMessageName }}.{{ $fmField.Name.UpperCamelCase }}.
    func (x *{{ $inMessageName }}) Mask_{{ $f.Name.UpperCamelCase }}() *{{ $inMessageName }} {
          if x.{{ $fmField.Name.UpperCamelCase}} == nil {
              x.{{ $fmField.Name.UpperCamelCase }} = new(fieldmaskpb.FieldMask)
          }
          x.{{ $fmField.Name.UpperCamelCase}}.Append(new({{ $outMessageName }}), "{{ $f.Name }}")

          return x
    }
{{ end}}

func (x *{{ $inMessageName }}) FieldMaskWithMode(mode pbfieldmask.MaskMode) *{{ $outMessageName }}_FieldMask {
    fm := &{{ $outMessageName }}_FieldMask{
        maskMode: mode,
        maskMapping: make(map[string]struct{}, len(x.{{ $fmField.Name.UpperCamelCase }}.GetPaths())),
    }

    for _, path := range x.{{ $fmField.Name.UpperCamelCase }}.GetPaths() {
        fm.maskMapping[path] = struct{}{}
    }

    return fm
}

// FieldMask_Prune generates *{{ $outMessageName }}_FieldMask with filter mode, so that
// only the fields in the {{ $inMessageName }}.{{ $fmField.Name.UpperCamelCase }} will be
// appended into the {{ $outMessageName }}.
func (x *{{ $inMessageName }}) FieldMask_Filter() *{{ $outMessageName }}_FieldMask {
	return x.FieldMaskWithMode(pbfieldmask.MaskMode_Filter)
}

// FieldMask_Prune generates *{{ $outMessageName }}_FieldMask with prune mode, so that
// only the fields NOT in the {{ $inMessageName }}.{{ $fmField.Name.UpperCamelCase }} will be
// appended into the {{ $outMessageName }}.
func (x *{{ $inMessageName }}) FieldMask_Prune() *{{ $outMessageName }}_FieldMask {
	return x.FieldMaskWithMode(pbfieldmask.MaskMode_Prune)
}

// {{ $outMessageName }}_FieldMask provide provide helper functions to deal with FieldMask.
type {{ $outMessageName }}_FieldMask struct {
    maskMode pbfieldmask.MaskMode
    maskMapping map[string]struct{}
}

{{ range $idx, $f := .OutMessage.Fields }}
    // Masked_{{ $f.Name.UpperCamelCase }} indicates the field {{ $outMessageName }}.{{ $f.Name.UpperCamelCase }}
    // exists in the {{ $inMessageName }}.{{ $fmField.Name.UpperCamelCase }} or not.
    func (x *{{ $outMessageName }}_FieldMask) Masked_{{ $f.Name.UpperCamelCase }}() bool {
          if x.maskMapping == nil {
              return false
          }

          _, ok := x.maskMapping["{{ $f.Name }}"]
          return ok
    }
{{ end}}


func (x *{{ $outMessageName }}_FieldMask) Mask(m *{{ $outMessageName }}) *{{ $outMessageName }} {
   switch x.maskMode {
   case pbfieldmask.MaskMode_Filter:
        x.filter(m)
   case pbfieldmask.MaskMode_Prune:
        x.prune(m)
   }

   return m
}

// filter will retain the fields those are in the maskMapping
func (x *{{ $outMessageName }}_FieldMask) filter(m proto.Message) {
    if len(x.maskMapping) == 0 {
        return
    }

    pr := m.ProtoReflect()
    pr.Range(func(fd protoreflect.FieldDescriptor, _ protoreflect.Value) bool {
        _, ok := x.maskMapping[string(fd.Name())]
        if !ok {
            pr.Clear(fd)
            return true
        }

        // TODO(@yeqown): support deeper fields masking
        return true
    })
}

// prune will remove fields those are in the maskMapping
func (x *{{ $outMessageName }}_FieldMask) prune(m proto.Message) {
    if len(x.maskMapping) == 0 {
        return
    }

    pr := m.ProtoReflect()
    pr.Range(func(fd protoreflect.FieldDescriptor, _ protoreflect.Value) bool {
        _, ok := x.maskMapping[string(fd.Name())]
        if !ok {
            return true
        }

        // TODO(@yeqown): support deeper fields masking
        pr.Clear(fd)
        return true
    })
}