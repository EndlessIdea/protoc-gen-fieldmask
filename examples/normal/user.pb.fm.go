// Code generated by protoc-gen-fieldmask. DO NOT EDIT.
// source: user.proto

package normal

import (
	pbfieldmask "github.com/yeqown/protoc-gen-fieldmask/proto/fieldmask"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
)

// UserInfoRequest is used for the template literal syntax.
// message generated by yeqown.

// Mask_UserId indicates append UserInfoResponse.UserId into
// UserInfoRequest.FieldMask.
func (x *UserInfoRequest) Mask_UserId() *UserInfoRequest {
	if x.FieldMask == nil {
		x.FieldMask = new(fieldmaskpb.FieldMask)
	}
	x.FieldMask.Append(new(UserInfoResponse), "user_id")

	return x
}

// Mask_Name indicates append UserInfoResponse.Name into
// UserInfoRequest.FieldMask.
func (x *UserInfoRequest) Mask_Name() *UserInfoRequest {
	if x.FieldMask == nil {
		x.FieldMask = new(fieldmaskpb.FieldMask)
	}
	x.FieldMask.Append(new(UserInfoResponse), "name")

	return x
}

// Mask_Email indicates append UserInfoResponse.Email into
// UserInfoRequest.FieldMask.
func (x *UserInfoRequest) Mask_Email() *UserInfoRequest {
	if x.FieldMask == nil {
		x.FieldMask = new(fieldmaskpb.FieldMask)
	}
	x.FieldMask.Append(new(UserInfoResponse), "email")

	return x
}

// Mask_Address indicates append UserInfoResponse.Address into
// UserInfoRequest.FieldMask.
func (x *UserInfoRequest) Mask_Address() *UserInfoRequest {
	if x.FieldMask == nil {
		x.FieldMask = new(fieldmaskpb.FieldMask)
	}
	x.FieldMask.Append(new(UserInfoResponse), "address")

	return x
}

func (x *UserInfoRequest) FieldMaskWithMode(mode pbfieldmask.MaskMode) *UserInfoResponse_FieldMask {
	fm := &UserInfoResponse_FieldMask{
		maskMode:    mode,
		maskMapping: make(map[string]struct{}, len(x.FieldMask.GetPaths())),
	}

	for _, path := range x.FieldMask.GetPaths() {
		fm.maskMapping[path] = struct{}{}
	}

	return fm
}

// FieldMask_Prune generates *UserInfoResponse_FieldMask with filter mode, so that
// only the fields in the UserInfoRequest.FieldMask will be
// appended into the UserInfoResponse.
func (x *UserInfoRequest) FieldMask_Filter() *UserInfoResponse_FieldMask {
	return x.FieldMaskWithMode(pbfieldmask.MaskMode_Filter)
}

// FieldMask_Prune generates *UserInfoResponse_FieldMask with prune mode, so that
// only the fields NOT in the UserInfoRequest.FieldMask will be
// appended into the UserInfoResponse.
func (x *UserInfoRequest) FieldMask_Prune() *UserInfoResponse_FieldMask {
	return x.FieldMaskWithMode(pbfieldmask.MaskMode_Prune)
}

// UserInfoResponse_FieldMask provide provide helper functions to deal with FieldMask.
type UserInfoResponse_FieldMask struct {
	maskMode    pbfieldmask.MaskMode
	maskMapping map[string]struct{}
}

// Masked_UserId indicates the field UserInfoResponse.UserId
// exists in the UserInfoRequest.FieldMask or not.
func (x *UserInfoResponse_FieldMask) Masked_UserId() bool {
	if x.maskMapping == nil {
		return false
	}

	_, ok := x.maskMapping["user_id"]
	return ok
}

// Masked_Name indicates the field UserInfoResponse.Name
// exists in the UserInfoRequest.FieldMask or not.
func (x *UserInfoResponse_FieldMask) Masked_Name() bool {
	if x.maskMapping == nil {
		return false
	}

	_, ok := x.maskMapping["name"]
	return ok
}

// Masked_Email indicates the field UserInfoResponse.Email
// exists in the UserInfoRequest.FieldMask or not.
func (x *UserInfoResponse_FieldMask) Masked_Email() bool {
	if x.maskMapping == nil {
		return false
	}

	_, ok := x.maskMapping["email"]
	return ok
}

// Masked_Address indicates the field UserInfoResponse.Address
// exists in the UserInfoRequest.FieldMask or not.
func (x *UserInfoResponse_FieldMask) Masked_Address() bool {
	if x.maskMapping == nil {
		return false
	}

	_, ok := x.maskMapping["address"]
	return ok
}

func (x *UserInfoResponse_FieldMask) Mask(m *UserInfoResponse) *UserInfoResponse {
	switch x.maskMode {
	case pbfieldmask.MaskMode_Filter:
		x.filter(m)
	case pbfieldmask.MaskMode_Prune:
		x.prune(m)
	}

	return m
}

// filter will retain the fields those are in the maskMapping
func (x *UserInfoResponse_FieldMask) filter(m proto.Message) {
	if len(x.maskMapping) == 0 {
		return
	}

	pr := m.ProtoReflect()
	pr.Range(func(fd protoreflect.FieldDescriptor, _ protoreflect.Value) bool {
		_, ok := x.maskMapping[string(fd.Name())]
		if !ok {
			pr.Clear(fd)
			return true
		}

		// TODO(@yeqown): support deeper fields masking
		return true
	})
}

// prune will remove fields those are in the maskMapping
func (x *UserInfoResponse_FieldMask) prune(m proto.Message) {
	if len(x.maskMapping) == 0 {
		return
	}

	pr := m.ProtoReflect()
	pr.Range(func(fd protoreflect.FieldDescriptor, _ protoreflect.Value) bool {
		_, ok := x.maskMapping[string(fd.Name())]
		if !ok {
			return true
		}

		// TODO(@yeqown): support deeper fields masking
		pr.Clear(fd)
		return true
	})
}
